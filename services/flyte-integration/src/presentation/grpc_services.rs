use std::sync::Arc;
use tonic::{Request, Response, Status};
use uuid::Uuid;

use crate::application::use_cases::FlyteClient;
use crate::application::use_cases::WorkflowUseCases;
use crate::domain::repositories::ExecutionRepository;

// Import the generated proto code
// This will be generated by build.rs from execution.proto
pub mod savassan {
    pub mod v1 {
        tonic::include_proto!("savassan.v1");
    }
}

use savassan::v1::{
    ExecuteWorkflowRequest, ExecuteWorkflowResponse, GetExecutionStatusRequest,
    GetExecutionStatusResponse, execute_workflow_response,
    execution_service_server::ExecutionService, get_execution_status_response,
};

/// gRPC service implementation for ExecutionService
pub struct ExecutionServiceImpl<R, F>
where
    R: ExecutionRepository,
    F: FlyteClient,
{
    use_cases: Arc<WorkflowUseCases<R, F>>,
}

impl<R, F> ExecutionServiceImpl<R, F>
where
    R: ExecutionRepository,
    F: FlyteClient,
{
    /// Create a new ExecutionService
    pub fn new(use_cases: Arc<WorkflowUseCases<R, F>>) -> Self {
        Self { use_cases }
    }
}

#[tonic::async_trait]
impl<R, F> ExecutionService for ExecutionServiceImpl<R, F>
where
    R: ExecutionRepository + 'static,
    F: FlyteClient + 'static,
{
    /// Execute a workflow by submitting it to Flyte
    async fn execute_workflow(
        &self,
        request: Request<ExecuteWorkflowRequest>,
    ) -> Result<Response<ExecuteWorkflowResponse>, Status> {
        let req = request.into_inner();

        tracing::info!(
            "Received execute workflow request for workflow_id: {}",
            req.workflow_id
        );

        // Parse the workflow JSON
        let workflow_json: serde_json::Value =
            serde_json::from_str(&req.flyte_workflow_definition_json).map_err(|e| {
                tracing::error!("Failed to parse workflow JSON: {e}");
                Status::invalid_argument(format!("Invalid workflow JSON: {e}"))
            })?;

        // Extract project and domain from the workflow definition or use defaults
        // In a real implementation, these would be extracted from the workflow JSON
        let project = workflow_json["project"]
            .as_str()
            .unwrap_or("flytesnacks")
            .to_string();
        let domain = workflow_json["domain"]
            .as_str()
            .unwrap_or("development")
            .to_string();

        // Execute the workflow through use cases
        match self
            .use_cases
            .execute_workflow(req.workflow_id, workflow_json, project, domain)
            .await
        {
            Ok(execution) => {
                tracing::info!(
                    "Successfully submitted workflow execution: {}",
                    execution.id
                );

                let response = ExecuteWorkflowResponse {
                    execution_id: execution.id.to_string(),
                    status: execute_workflow_response::Status::Submitted as i32,
                };

                Ok(Response::new(response))
            }
            Err(e) => {
                tracing::error!("Failed to execute workflow: {}", e);

                // Return a failed response instead of an error status
                // This allows the client to know that the request was processed
                // but the workflow submission failed
                let response = ExecuteWorkflowResponse {
                    execution_id: String::new(),
                    status: execute_workflow_response::Status::Failed as i32,
                };

                Ok(Response::new(response))
            }
        }
    }

    /// Get the status of a workflow execution
    async fn get_execution_status(
        &self,
        request: Request<GetExecutionStatusRequest>,
    ) -> Result<Response<GetExecutionStatusResponse>, Status> {
        let req = request.into_inner();

        tracing::info!(
            "Received get execution status request for: {}",
            req.execution_id
        );

        // Parse execution ID as UUID
        let execution_id = Uuid::parse_str(&req.execution_id).map_err(|e| {
            tracing::error!("Invalid execution ID format: {}", e);
            Status::invalid_argument(format!("Invalid execution ID: {e}"))
        })?;

        // Get execution status through use cases
        match self.use_cases.get_execution_status(execution_id).await {
            Ok(execution) => {
                let status = match execution.status {
                    crate::domain::models::ExecutionStatus::Pending => {
                        get_execution_status_response::Status::Pending
                    }
                    crate::domain::models::ExecutionStatus::Submitted => {
                        get_execution_status_response::Status::Pending
                    }
                    crate::domain::models::ExecutionStatus::Running => {
                        get_execution_status_response::Status::Running
                    }
                    crate::domain::models::ExecutionStatus::Succeeded => {
                        get_execution_status_response::Status::Succeeded
                    }
                    crate::domain::models::ExecutionStatus::Failed => {
                        get_execution_status_response::Status::Failed
                    }
                    crate::domain::models::ExecutionStatus::Aborted => {
                        get_execution_status_response::Status::Aborted
                    }
                    crate::domain::models::ExecutionStatus::TimedOut => {
                        get_execution_status_response::Status::TimedOut
                    }
                };

                let response = GetExecutionStatusResponse {
                    execution_id: execution.id.to_string(),
                    status: status as i32,
                    message: execution.error_message.unwrap_or_default(),
                    started_at: execution
                        .started_at
                        .map(|dt| dt.to_rfc3339())
                        .unwrap_or_default(),
                    completed_at: execution
                        .completed_at
                        .map(|dt| dt.to_rfc3339())
                        .unwrap_or_default(),
                };

                Ok(Response::new(response))
            }
            Err(e) => {
                tracing::error!("Failed to get execution status: {e}");
                Err(Status::not_found(format!("Execution not found: {e}")))
            }
        }
    }
}
